## 1. 需求
在 EOS 中，智能合约执行完毕后，所占用的内存会释放。程序中的所有变量都会丢失。如果智能合约里要持久地记录信息，比如游戏智能合约要记录每位用户游戏记录，本次合约执行完毕后数据不能丢失，就需要将数据存储到 EOS 数据库中。EOS区块链数据与以太坊的存储不一样，以太坊只要是solidity合约中的变量都能够永久存储（这个说明不一定准确），但是EOS中的变量都是临时的，如果需要永久存储，就需要往数据库中写入。

持久化技术应该包括：
1. 记录一些状态持久化到数据库中
2. 具备查询的能力从数据库中获取内容
3. 提供C++ 的API来调用这些服务，也服务于合约开发者

下图说明了 EOS 智能合约在执行 Action 时，与数据库的交互过程
![0_1529981985097_action-apply-context-diagram.png](/assets/uploads/files/1529981991254-action-apply-context-diagram-resized.png) 

P.S. EOS官方使用的数据库是一个叫shared memory的。

## 2. Multi-Index API
EOS的Multi-Index API提供了C++接口让其能够访问底层数据库，Multi-Index实际上是模仿Boost库中的boost::multi_index的功能开发的一套库。

在 EOS 中，为每个账户都预留了数据库空间（大小与代币持有量有关），每个账户名下可以建立多个数据表。智能合约无法直接操作存储在硬盘中的数据表，需要使用multi_index作为中间工具，每个multi_index实例都与一个特定账户的特定数据表进行交互（取决于实例化时的参数）。

EOS智能合约与EOS数据库的数据交互如下图所示：
![0_1529982949586_multi-index.png](/assets/uploads/files/1529982952142-multi-index-resized.png) 

## 3. 结构
### 3.1 数据表
multi_index是一个非常方便的数据库交互容器，可以存储任何 C++ 数据类型。每一个multi_index都相当于传统数据库的一个数据表（table），但将传统数据库的行与列的形式改为了单纯的列。也就是说multi_index是一个线性排列的表，只有一列，每一行都只存储一个对象。但是一般来说multi_index存储的对象都是结构体或者类，里面含有多个成员变量，所以multi_index存储数据的灵活性也是不亚于传统数据库的。

### 3.2 多索引
首先，每个数据表要有一组主键，主键必须是无符号 64 位整数类型（64-bit integer）。在数据表中，所有的对象就是按照主键升序排列的，小的在前，大的在后。主键可以是有意义的，也可以是没有意义的，让系统产生一个在这个数据表中没有被使用的主键即可。

multi_index从字面上看就是能使用多个索引的数据表。EOS 中，每个multi_index或者说每个数据表都可以设置最多16个索引。索引相当于使用特定的方式给数据表中的对象重新排序。比如在我们经常使用的 windows 文件管理器中，可以按照文件名排序、按照文件修改时间排序、按照文件大小排序，这就有了3个索引。EOS 数据库索引更加灵活，可以单独按照结构体中的某个变量索引，也可以将变量之间的运算结果（函数输出）进行索引。

### 3.3 迭代器
multi_index是如何操作数据表中的每个对象的呢？答案是 Iterators（迭代器）。大家可以搜索 “C++ 迭代器”或者设计模式中的“迭代器模式”来了解迭代器的设计思路。在 EOS 数据库中，我更愿意将迭代器比喻为一个“电梯”，在整个数据表中上下穿梭。所有对数据的操作必须通过迭代器完成。典型的数据修改过程是这样的：首先使用迭代器的find()方法，在特定的索引中寻找需要的数据，迭代器会移动到需要的数据对象上。然后就可以使用迭代器的modify()方法修改当前迭代器对应的数据。

## 参考文献
[【许晓笛】EOS 数据库与持久化 API](https://blog.csdn.net/yuanfangyuan_block/article/details/80403360)
